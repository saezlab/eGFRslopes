---
title: "4. Joint modelling of eGFR slopes"
author: "Elif DoÄŸan Dar"
date: "2023-06-16"
output: workflowr::wflow_html
editor_options:
  chunk_output_type: console
---

## Introduction

Now we finally come to modelling the eGFR slopes. 

A useful reference is [A Tutorial for Joint Modeling of Longitudinal and Time-to-Event Data in R](https://doi.org/10.5964/qcmb.2979).
 

Load necessary libraries:
```{r, include = FALSE, message = FALSE}
library(dplyr)
library(tidyverse)
library(lattice)
library(ggplot2)
library(nlme)
library(survival)
library(broom.mixed)    # augment()
library(JMbayes2)       # jm(), compare_jm
```

Load the data:

```{r}
eGFR_minimal <- read.csv("output/eGFR_minimal.csv")
```

## Joint model

The `jmbayes2::jm()` function takes a `Surv_object`, the object giving the time-to-event submodel, and `Mixed_objects`, containing the longitudinal mixed-effects model. `Surv_object` should be of the class generated by `coxph()` or `survreg()` from the `survival` package, and `Mixed_objects` should be of the class generated by `nlme::lme()` or `GLMMadaptive::mixed_model()`. Here, we use the `survival` and `nlme` packages.

Note that in the joint modelling context we need to set `x = TRUE` (or equivalently
`model = TRUE`) in the call of the `coxph()` function so that the design matrix 
used in the Cox model is returned in the object fit.

By default, `jm()` adds the subject-specific linear predictor of the mixed model 
as a time-varying covariate in the survival relative risk model. In the output 
this is named as `value(y)` to denote that, by default, the current 
value functional form is used. That is, we assume that the instantaneous risk 
of an event at a specific time $t$ is associated with the value of the linear 
predictor of the longitudinal outcome at the same time point $t$.

### Time-to-event submodel

Construct the dataset for the time-to-event i.e. survival submodel:
```{r}
eGFR_minimal <- eGFR_minimal[order(eGFR_minimal$patient_id, eGFR_minimal$start),]
eGFR_minimal_surv <- eGFR_minimal[!duplicated(eGFR_minimal$patient_id),]
eGFR_minimal_surv <- eGFR_minimal_surv  %>%
  dplyr::select(last_measurement_y, endpoint, disease, patient_id, 
                age_at_biopsy, sex  )
```

Fit the survival sub-model:
```{r}
fitSURV1 <- survival::coxph(Surv(last_measurement_y, endpoint) ~ 
                              disease, 
                           data = eGFR_minimal_surv,
                           x = TRUE,
                           model = TRUE)
```

### Longitudinal mixed-effects submodel

Select only the columns we need:
```{r}
eGFR_minimal <- eGFR_minimal %>%
  dplyr::select(measurement, disease, start, age_at_biopsy, patient_id,
                last_measurement_y, endpoint)

knitr::kable(head(eGFR_minimal))
```

Fit the longitudinal sub-model:
```{r}
fitLME1 <- nlme::lme(fixed = measurement ~ 1 + start + disease + age_at_biopsy ,
                    data = eGFR_minimal,random = ~1 + start | patient_id)
```

### Joint model

Fitting the joint model:
```{r}
fitJMbayes1 <- JMbayes2::jm(Surv_object = fitSURV1,
                    Mixed_objects = fitLME1,
                   time_var = 'start')
```

In practise, when fitting our models to real data, we have found the need to increase the parameter `n_iter` e.g. to `n_iter = 11000L` or `n_iter = 30000L`.

```{r}
summary(fitJMbayes1)
```

Use the `predict` function to generate the fitted slope from the joint model:

```{r}
pred_long <- predict(fitJMbayes1, eGFR_minimal, process = 'longitudinal',
                     type = "subject_specific", 
                     return_newdata = TRUE)
```

We can plot for an individual patient using the `plot` function:

```{r}
plot(pred_long, subject = 15)
```

Plot for the first twenty patients in our cohort:
```{r}
pred_long %>%
  dplyr::filter(patient_id %in% 1:20) %>%
  ggplot() +
    geom_point(aes(x = start, y = measurement), size = .5) +
    geom_line(aes(x = start, y = pred_measurement), color="#00BFC4", linewidth =.5)+
  facet_wrap(~patient_id)
```

## Save data

Save predictions for plotting and extracting slopes:
```{r}
write.csv(pred_long, file = "output/pred_long.csv", row.names = FALSE)
```

Save the model object:
```{r}
saveRDS(fitJMbayes1, file = "output/fitJMbayes.RDS")
```
